# Лекция № 1

## Содержание

- Bash-скрипт
- Условия
- Циклы
- Аргументы
- Функции
- Ссылки на материалы

## Bash скрипт

Командная строка — отличный инструмент, но команды в неё приходится вводить каждый раз, когда в них возникает необходимость. Что если записать набор команд в файл и просто вызывать этот файл для их выполнения? Собственно говоря, тот файл, о котором мы говорим, и называется сценарием командной строки.

```bash
touch evil.sh # Создаем файл в текущей директории
vim ./evil.sh # Открываем файл в vim
```

Добавим в файл следующие строчки:

```bash
#!/bin/bash
pwd # Выведет текущую рабочую директорию (не обязательно месторасположение самого скрипта)
whoami # Выведет текущего пользователя
```

Установим права на запуск для скрипта и запустим его:

`chmod u+x ./evil.sh ; ./evil.sh`

Перепишем скрипт, чтобы посмотреть, как пользоваться переменными и выводить более осмысленные сообщения:

```bash
#! /bin/bash
directory=`pwd` # Выполнили команду pwd и записали результат в переменную directory
user=$(whoami) # Выполнили команду whoami и записали результат в переменную user
echo "Текущая директория: $directory" # Читаем из переменной
echo "Текущий пользователь: $user"
echo "Домашняя папка: $HOME" # Выводим путь домашней директории из переменной окружения
```

## Условия

Cинтаксис: 

```bash
if команда ; then
  команды
elif команда ; then
  команды
else
  команды
fi
```

Сравнение чисел:

`[ n1 -eq n2 ]` Возвращает истинное значение, если n1 равно n2.  
`[ n1 -ge n2 ]` Возвращает истинное значение, если n1больше или равно n2.  
`[ n1 -gt n2 ]` Возвращает истинное значение, если n1 больше n2.  
`[ n1 -le n2 ]` Возвращает истинное значение, если n1 меньше или равно n2.  
`[ n1 -lt n2 ]` Возвращает истинное значение, если n1 меньше n2.  
`[ n1 -ne n2 ]` Возвращает истинное значение, если n1 не равно n2.

Сравнение строк:

`[ str1 = str2 ]` Проверяет строки на равенство, возвращает истину, если строки идентичны.  
`[ str1 != str2 ]` Возвращает истину, если строки не идентичны.  
`[ str1 < str2 ]` Возвращает истину, если str1 меньше, чем str2.  
`[ str1 > str2 ]` Возвращает истину, если str1 больше, чем str2.  
`[ -n str1 ]` Возвращает истину, если длина str1 больше нуля.  
`[ -z str1 ]` Возвращает истину, если длина str1 равна нулю.

**ВНИМАНИЕ! Пробелы для квадратных скобок важны!**

Пример:

```bash
#! /bin/bash
i=10
s="qwerty"
if [ $i -eq 0 ] ; then
  echo "i is zero"
elif [ $i -gt 0 && -n $s ] ; then
  echo "i is > 0 and s is not zero length"
else
  echo "s is zero length"
fi
```

Для работы с числами можно использовать другой подход:
```bash
#! /bin/bash
i=10
if (( $i == 0 )) ; then
  echo "i is zero"
elif (( $i > 0 )) && [ -n $s ] ; then
  echo "i is > 0 and s is not zero length"
else
  echo "s is zero length"
fi
```

`[[ ]]` - наиболее современный вариант, вместо `[ ]`

## Циклы

```bash
#! /bin/bash
# Создадим 3 группы пользователей
for group in xackers sheeps dogs ; do
  groupadd $group
done

# Создадим 100 пользователей и распределим их по группам
for i in $(seq 1 1 100) ; do
  if [[ $i -le 33 ]] ; then
    useradd user_$i -g xackers # Создаем пользователя и добавляем его в группу xackers
  elif [[ $i -le 66 ]] ; then
    useradd user_$i -g sheeps
  else
    useradd user_$i -g dogs
  fi
done

cat /etc/passwd # Выведем всех пользователей в системе
```

Еще один пример:

```bash
#! /bin/bash
# В каждой директории создадим по 3 файла
for dir in ./*
do
  for name in readme.md license passwords.txt
  do
  touch $dir/$name
  done 
done

ls -Rp
```

## Аргументы

```bash
#! /bin/bash
echo "arg count: $#" # Вывод количества аргументов
for i in $@ ; do # $@ выдает все аргументы как отдельные строки
  echo "arg: $i"
done

echo "script file: $0" # Вывод месторасположения файла скрипта
echo "first arg: $1, third arg: $3" # Вывод 1го и 3го аргумента
```

## Функции

```bash
#! /bin/bash
myfunc() {
    echo "hello $1"
}

myfunc Xacker # Получим вывод hello Xacker
```

## Ссылки на материалы

- https://habr.com/ru/companies/ruvds/articles/325522/
- https://www.geeksforgeeks.org/bash-scripting-if-statement/
- https://devhints.io/bash

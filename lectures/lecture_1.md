# Лекция № 1

## Bash скрипт

Командная строка — отличный инструмент, но команды в неё приходится вводить каждый раз, когда в них возникает необходимость. Что если записать набор команд в файл и просто вызывать этот файл для их выполнения? Собственно говоря, тот файл, о котором мы говорим, и называется сценарием командной строки.

```bash
touch evil.sh # Создаем файл в текущей директории
vim ./evil.sh # Открываем файл в vim
```

Добавим в файл следующие строчки:

```bash
#!/bin/bash
pwd # Выведет текущую рабочую директорию (не обязательно месторасположение самого скрипта)
whoami # Выведет текущего пользователя
```

Установим права на запуск для скрипта и запустим его:

`chmod +x ./evil.sh ; ./evil.sh`

Перепишем скрипт, чтобы посмотреть, как пользоваться переменными и выводить более осмысленные сообщения:

```bash
#! /bin/bash
directory=`pwd` # Выполнили команду pwd и записали результат в переменную directory
user=$(whoami) # Выполнили команду whoami и записали результат в переменную user
echo "Текущая директория: $directory" # Читаем из переменной
echo "Текущий пользователь: $user"
echo "Домашняя папка: $HOME" # Выводим путь домашней директории из переменной окружения
```
### Циклы

Создадим 100 папок в текущей директории:

```bash
echo "Создаю папки"
for ((i=0;i<100;i++))
do # начало тела цикла
mkdir ./dir$i # mkdir создает папку в текущей директории
done # конец тела цикла
ls -p # Убедимся, что папки созданы
```

В каждой папке создадим по 3 файла

```bash
for dir in ./* # цикл по всем объектам (папкам и файлам в т.ч.) в директории
do
  for name in readme.md license passwords.txt # цикл по списку
  do
  touch $dir/$name
  done 
done
```

Итоговый скрипт:

```bash
echo "Создаю папки"
for ((i=0;i<100;i++))
do
mkdir ./dir$i
done

for dir in ./*
do
  for name in readme.md license passwords.txt
  do
  touch $dir/$name
  done 
done

ls -Rp
```

## Условия

Cинтаксис: 

```bash
if команда ; then
  команды
elif команда ; then
  команды
else
  команды
fi
```

Сравнение чисел:

`[ n1 -eq n2 ]` Возвращает истинное значение, если n1 равно n2.  
`[ n1 -ge n2 ]` Возвращает истинное значение, если n1больше или равно n2.  
`[ n1 -gt n2 ]` Возвращает истинное значение, если n1 больше n2.  
`[ n1 -le n2 ]` Возвращает истинное значение, если n1меньше или равно n2.  
`[ n1 -lt n2 ]` Возвращает истинное значение, если n1 меньше n2.  
`[ n1 -ne n2 ]` Возвращает истинное значение, если n1 не равно n2.

Сравнение строк:

`[ str1 = str2 ]` Проверяет строки на равенство, возвращает истину, если строки идентичны.  
`[ str1 != str2 ]` Возвращает истину, если строки не идентичны.  
`[ str1 < str2 ]` Возвращает истину, если str1 меньше, чем str2.  
`[ str1 > str2 ]` Возвращает истину, если str1 больше, чем str2.  
`[ -n str1 ]` Возвращает истину, если длина str1 больше нуля.  
`[ -z str1 ]` Возвращает истину, если длина str1 равна нулю.

**ВНИМАНИЕ! Пробелы для квадратных скобок важны!**

Пример:

```bash
#! /bin/bash
i=10
s="qwerty"
if [ $i -eq 0 ] ; then
  echo "i is zero"
elif [ $i -gt 0 ] and [ -n $s ] ; then
  echo "i is >= 0 and s is not zero length"
else
  echo "i is = 0 or s is zero length"
fi
```

`[[ ]]` - наиболее современный вариант, вместо `[ ]`

## Ссылки на материалы

- https://habr.com/ru/companies/ruvds/articles/325522/
- https://www.geeksforgeeks.org/bash-scripting-if-statement/
